
@startuml Fingerprint Run and Graph Pruning


'TODO:
'don't add to cache class, create object or dynamic subclass
' create -> init
' storage?

participant GraphTrainer order 3

control GraphRunner <<Infrastructure>> order 5
participant GraphNode order 7
entity GraphFingerprintComponent order 8
entity GraphComponent order 9
database Cache <<Infrastructure>> order 10

== Preparing the Graph ==

GraphTrainer -> Cache: create()
GraphTrainer <-- Cache: cache
note over GraphFingerprintComponent: Adding the cache to the class means that all instantiated GraphFingerprintComponent can mark their statuses when run.
GraphTrainer -> GraphFingerprintComponent: create_subclass_with_cache(cache)
GraphTrainer <-- GraphFingerprintComponent: graph_fingerprint_component_class

GraphTrainer -> GraphTrainer: replace_non_input_node_components_with_fingerprint_node_component(train_schema, cache, graph_fingerprint_component_class)

GraphTrainer -> GraphRunner: graph_runner_class.create(train_schema)

GraphRunner -> GraphRunner: instantiate_graph()

group instantiate_graph (for every graph node in schema)

    GraphRunner -> GraphNode: ~__init__(nodename, config)

    group if GraphFingerprintComponent
        GraphNode -> GraphFingerprintComponent: ~__init__(node_name, config)
        GraphNode <-- GraphFingerprintComponent: fingerprint_node_component
    end
    group elif GraphComponent
        GraphNode -> GraphComponent: create(node_name, config)
        GraphNode <-- GraphComponent: node_component
    end
    GraphRunner <-- GraphNode: node
end


GraphTrainer <-- GraphRunner: graph_runner

== Fingerprint Run ==

GraphTrainer -> GraphRunner: run(train_targets, training_filepaths)

GraphRunner -> GraphRunner: insert_inputs_in_instantiated_graph(training_filepaths)

GraphRunner -> GraphRunner: execute(instantiated_graph, targets)

group execute (for graph_node in sorted(graph_nodes))
    GraphRunner -> GraphNode: run(inputs_from_previous_node)

    'TODO: edge nodes are still GraphComponent
    group if GraphFingerprintComponent
        GraphNode -> GraphFingerprintComponent: run(inputs)
        'TODO: cache using component_name not node_name
        note over Cache: This returns the fingerprint if there is a match, indicating that the execution will be the same as a previous run.
        GraphFingerprintComponent -> Cache: get_fingerprint(node_name, config, inputs_from_previous_node)
        group if fingerprint match
            GraphFingerprintComponent <-- Cache: fingerprinted_result
            note over Cache: Marking the node as a "hit" means that we can potentially cache or prune this node.
            GraphFingerprintComponent -> Cache: mark_node_hit(node_name)
        end
        group else
            GraphFingerprintComponent <-- Cache: None
            note over Cache: Marking the node as a "miss" means that we will need to rerun this node.
            GraphFingerprintComponent -> Cache: mark_node_miss(node_name)
        end
        GraphNode <-- GraphFingerprintComponent: output
    end
    group elif GraphComponent
        GraphNode -> GraphFingerprintComponent: run(inputs)
        GraphNode <-- GraphFingerprintComponent: output
    end
    GraphRunner <-- GraphNode
end

GraphTrainer <-- GraphRunner

== Pruning ==

note over GraphTrainer: This will walk through the graph using the cache to determine if a node should be rerun, cached, or removed.
GraphTrainer -> GraphTrainer: update_statuses(cache, train_schema)
GraphTrainer -> GraphTrainer: replace_cached_nodes(cache, train_schema)
GraphTrainer -> GraphTrainer: remove_unneeded_nodes(cache, train_schema)

@enduml
