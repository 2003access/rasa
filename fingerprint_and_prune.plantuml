
@startuml Fingerprint Run and Graph Pruning

participant GraphTrainer order 3

control GraphRunner <<Infrastructure>> order 5
participant GraphNode order 7
entity GraphFingerprintComponent order 8
entity GraphComponent order 9
database Cache <<Infrastructure>> order 10

== Preparing the Graph ==

GraphTrainer -> Cache: create()
GraphTrainer <-- Cache: cache

GraphTrainer -> GraphTrainer: replace_non_input_node_components_with_fingerprint_node_component(train_schema, cache)
group replace_non_input_node_components_with_fingerprint_node_component (for each GraphFingerprintComponent)
    note over GraphFingerprintComponent: Adding the cache to the class means that all instantiated GraphFingerprintComponent can mark their statuses when run.
    GraphTrainer -> GraphFingerprintComponent: add_cache_to_class(cache)
end

GraphTrainer -> GraphRunner: graph_runner_class.create(train_schema)

GraphRunner -> GraphRunner: instantiate_graph()

group instantiate_graph (for every graph node in schema)

    GraphRunner -> GraphNode: create(nodename, config)

    group if GraphFingerprintComponent
        GraphNode -> GraphFingerprintComponent: create(node_name, config)
        GraphNode <-- GraphFingerprintComponent: fingerprint_node_component
    end
    group elif GraphComponent
        GraphNode -> GraphComponent: create(node_name, config)
        GraphNode <-- GraphComponent: node_component
    end
    GraphRunner <-- GraphNode: node
end


GraphTrainer <-- GraphRunner: graph_runner

== Fingerprint Run ==

GraphTrainer -> GraphRunner: run(train_targets, training_filepaths)

GraphRunner -> GraphRunner: insert_inputs_in_instantiated_graph(training_filepaths)

GraphRunner -> GraphRunner: execute(instantiated_graph, targets)

group execute (for graph_node in sorted(graph_nodes))
    GraphRunner -> GraphNode: run(inputs_from_previous_node)

    'TODO: edge nodes are still GraphComponent
    group if GraphFingerprintComponent
        GraphNode -> GraphFingerprintComponent: run(inputs)
        'TODO: cache using component_name not node_name
        note over Cache: This returns the fingerprint if there is a match, indicating that the execution will be the same as a previous run.
        GraphFingerprintComponent -> Cache: get_fingerprint(node_name, config, inputs_from_previous_node)
        group if fingerprint match
            GraphFingerprintComponent <-- Cache: fingerprinted_result
            note over Cache: Marking the node as a "hit" means that we can potentially cache or prune this node.
            GraphFingerprintComponent -> Cache: mark_node_hit()
        end
        group else
            GraphFingerprintComponent <-- Cache: None
            note over Cache: Marking the node as a "miss" means that we will need to rerun this node.
            GraphFingerprintComponent -> Cache: mark_node_miss()
        end
        GraphNode <-- GraphFingerprintComponent: output
    end
    group elif GraphComponent
        GraphNode -> GraphFingerprintComponent: run(inputs)
        GraphNode <-- GraphFingerprintComponent: output
    end
    GraphRunner <-- GraphNode
end

GraphTrainer <-- GraphRunner

== Pruning ==

note over GraphTrainer: This will walk through the graph using the cache to determine if a node should be rerun, cached, or removed.
GraphTrainer -> GraphTrainer: update_statuses(cache, train_schema)
GraphTrainer -> GraphTrainer: replace_cached_nodes(cache, train_schema)
GraphTrainer -> GraphTrainer: remove_unneeded_nodes(cache, train_schema)

@enduml
